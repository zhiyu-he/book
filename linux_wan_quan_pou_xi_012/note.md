1. P17:  CPU通过地址线、数据线、控制信号线组成本地总线与系统其他部分进行数据通信。
	* 地址线: 提供内存, IO设备的地址
	* 数据线: 为CPU与内存、IO设备提供数据传输的通道
	* 控制线: 执行的读写操作
	* 对于80386而言, 地址线和数据线分别有32根, 即都为32位, 寻址范围`2^32`字节, 从0到4GB
2. P19~21: I/O控制器=数据端口+输出命令端口+访问控制器执行状态端口; 独立编址与统一编址
	* 统一编址: 将IO设备归入存储器的寻址范围, 32bit, 0~2^32?
	* 独立编址: 独立的地址空间编码, 使用单独的指令来访问
	* 访问控制:
		* 程序循环查询, 浪费CPU时间
		* 中断处理, 需要中断控制器支持, 中断向量表
		* DMA传输, Direct Memory Access, 通过DMA控制器直接进行处理,将数据从IO设备拷贝到内存CPU不参与
3. P23: 在内存0x000~0xFFF, 建立中断向量表4K?
4. P33: `.`本身是一个特殊符号, 它表示编译过程中的位置计数器
5. P75~P80: 寄存器的分类,`控制寄存器`, `内存管理寄存器`, `标志寄存器`
6. P81: 为了对内存寻址, X86使用了一种段(Segement)的寻指技术。即内存的地址=段地址+段内偏移。其中段地址16位, 段内偏移32位。整体组成了一个48位的逻辑地址。
	* 为什么需要48位的逻辑地址？
7. P81: X86提供了6个代码段, CS, DS, ES, SS, FS, GS.
	* CS: 代码段, EIP, 当前代码段内下一条要执行的指令, CS:[EIP]
	* SS: 堆栈段, ESP, 指向当前的栈顶, SS:[ESP]
	* 其他的为通用段寄存器, `DS: 数据段`; 
	* 寻址方式, 偏移地址= 基地址+ (变指 X 比例因子) + 偏移量
8. P82: 内存管理的关键=保护+地址变换
9. P82: `分段机制`提供了隔绝各个代码、数据和堆栈区域的机制，因此多个程序可以运行在同一个处理器上而会互相干扰; `分页机制`为传统需求页、虚拟内存系统提供了实现机制。
10. P82: `段描述符`指明段大小、访问权限和段特权级别、段类型及段的第一个字节在线性地址空间中的位置（称为段的基地址）
	* [TODO]需要进一步探寻一下, 段与分页的不同地位与协作！
11. P85: 分段机制的定义与作用
	* 定义: 段=段基址+段限长+段属性 => 段描述符(Segment Descriptor)存储于段描述符表(Descriptor Table)
	* 映射过程:
		* 使用`段选择符`中偏移值(段索引)在GDT或LDT表中定位相应的段描述符。(仅当一个新的段选择符加载到段寄存器中时才需要这一步)
		* 利用`段描述符`校验段的访问权限和范围，以确保该段是可以访问的并且偏移量位于段界限内。
		* 把段描述符中取得的段基地址加到偏移量上，最后形成一个线形地址
		* [TODO] 对于每个进程来说 段选择符, 在PCB里面么？
	* 段描述符表=GDT+LDT=2^14, 每个表各有8192个段
	